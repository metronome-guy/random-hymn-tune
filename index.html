<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Random Hymn Tune</title>
  <style>
    :root {
      --panel-gap: 8px;
      --panel-pad: 8px;

      --gold: #FFC600;
      --gold-border: #d7a900;

      --gold-lite: #FFEFAD;
      --gold-lite-border: #E6D48A;
      --gold-lite-hover: #FFE68A;

      --btn-blue: #0a64dc;
      --btn-blue-hover: #084fb0;
      --btn-lightblue: #5ab6ff;
      --btn-lightblue-hover: #3fa8ff;
      --btn-red: #d32f2f;
      --btn-red-hover: #b71c1c;
      --btn-pink: #ff6fb3;
      --btn-pink-hover: #ff4fa3;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0; padding: 12px; background: #f7f7f9;
    }

    #controlsBar {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 8px;
    }

    .control-group {
      display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap;
    }

    button {
      color: #fff; border: none; border-radius: 8px;
      padding: 8px 12px; font-size: 0.95rem; cursor: pointer;
      transition: background-color 120ms ease, opacity 120ms ease;
    }
    button[disabled] { opacity: 0.6; cursor: not-allowed; }

    .btn-random { background: var(--btn-red); }
    .btn-random:hover { background: var(--btn-red-hover); }

    .btn-oct { background: var(--btn-pink); }
    .btn-oct:hover { background: var(--btn-pink-hover); }

    .btn-spacing { background: var(--btn-blue); }
    .btn-spacing:hover { background: var(--btn-blue-hover); }

    .btn-music { background: var(--btn-lightblue); color: #042a46; }
    .btn-music:hover { background: var(--btn-lightblue-hover); }

    .status-badge {
      padding: 2px 8px; background: #fff; border: 1px solid #ddd; border-radius: 8px;
      font-weight: 600; color: #333;
    }

    #titleBar {
      background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 6px 10px;
      font-weight: 700; color: #333; margin: 4px 0 8px;
    }

    #viewer {
      background: #fff; border: 1px solid #ddd; border-radius: 10px; padding: 4px; min-height: 200px;
      overflow-x: auto;
      overscroll-behavior-x: contain;
      margin-bottom: 8px;
    }

    #svg { width: 100%; height: auto; }
    #svg svg { display: block; }

    #optionsBar {
      display: flex; align-items: flex-start; gap: var(--panel-gap); flex-wrap: wrap; margin-bottom: 8px;
    }

    .panel {
      background: #fff; border: 1px solid #ddd; border-radius: 8px;
      padding: var(--panel-pad); display: inline-flex; align-items: flex-start; gap: 10px;
    }
    .panel legend { font-weight: 700; font-size: 0.9rem; margin-right: 6px; }

    #exPanel { flex-basis: 100%; }

    .row { display: inline-flex; align-items: center; gap: 10px; flex-wrap: wrap; }

    .panel-tools {
      display: inline-flex;
      gap: 6px;
      margin-left: 8px;
      vertical-align: middle;
    }

    .tool-btn {
      padding: 4px 8px;
      font-size: 0.82rem;
      border-radius: 6px;
      background: var(--gold-lite);
      color: #3b2f00;
      border: 1px solid var(--gold-lite-border);
      cursor: pointer;
    }
    .tool-btn:hover { background: var(--gold-lite-hover); }

    .chk-label {
      display: inline-flex; align-items: center; gap: 6px; font-size: 0.95rem;
      padding: 2px 6px; border-radius: 6px; border: 1px solid #ddd; background: #fff;
      transition: background-color 120ms ease, border-color 120ms ease;
    }
    .chk-label input[type="checkbox"] {
      appearance: none; width: 14px; height: 14px; border-radius: 3px; border: 1px solid #666;
      position: relative; margin-right: 2px; background: #fff;
      transition: background-color 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .chk-label input[type="checkbox"]::after {
      content: ""; position: absolute; inset: 3px; border-radius: 2px; background: #333; opacity: 0; transition: opacity 120ms ease;
    }
    .chk-label input[type="checkbox"]:checked {
      background: var(--gold); border-color: var(--gold-border); box-shadow: 0 0 0 2px rgba(255, 198, 0, 0.25);
    }
    .chk-label input[type="checkbox"]:checked::after { opacity: 1; }
    .chk-label span { padding: 0 4px; border-radius: 4px; border: 1px solid transparent; color: #222; background: transparent; }

    .key-range { display: inline-flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .key-range .range-btn {
      padding: 4px 8px; font-size: 0.85rem; border-radius: 6px; background: #666; color: #fff; border: 1px solid transparent;
    }
    .key-range .range-btn:hover { background: #444; }
    .key-range .range-btn.active { background: var(--gold); color: #222; border: 1px solid var(--gold-border); }

    footer { margin-top: 8px; color: #777; font-size: 0.85rem; }
  </style>
</head>
<body>
  <div id="controlsBar">
    <button id="randomBtn" class="btn-random" type="button" disabled>Show Random Tune</button>

    <span id="statusTune" class="status-badge">File: —</span>
    <span id="statusKey"  class="status-badge">Key: —</span>

    <button id="octUpBtn"   class="btn-oct" type="button" disabled title="Transpose up 8va">8va↑</button>
    <button id="octDownBtn" class="btn-oct" type="button" disabled title="Transpose down 8va">8va↓</button>

    <button id="enharmonicBtn" class="btn-music" type="button" disabled
      title="Toggle enharmonic spelling (Db/C#, Eb/D#, Gb/F#, Ab/G#, Cb/B)">♯/♭</button>

    <button id="halfUpBtn" class="btn-music" type="button" disabled title="Transpose current tune up a half step">Half step↑</button>
    <button id="halfDownBtn" class="btn-music" type="button" disabled title="Transpose current tune down a half step">Half step↓</button>

    <div class="control-group" id="groupSpacing">
      <button id="spacingPlusBtn"  class="btn-spacing" type="button" disabled title="Increase spacing between notes">spacing+</button>
      <button id="spacingMinusBtn" class="btn-spacing" type="button" disabled title="Decrease spacing between notes">spacing−</button>
      <span id="spacingBadge" class="status-badge">Spacing: —</span>
    </div>

    <div class="control-group" id="groupScale">
      <button id="musicPlusBtn"  class="btn-music" type="button" disabled title="Increase music size">Music+</button>
      <button id="musicMinusBtn" class="btn-music" type="button" disabled title="Decrease music size">Music−</button>
      <span id="scaleBadge" class="status-badge">Scale: —</span>
    </div>
  </div>

  <div id="titleBar" aria-live="polite">Title: —</div>
  <div id="viewer"><div id="svg"></div></div>

  <div id="optionsBar">
    <fieldset class="panel" id="keysPanel">
      <legend>
        Key range
        <span class="panel-tools">
          <button class="tool-btn" type="button" id="keysAllBtn">all</button>
          <button class="tool-btn" type="button" id="keysNoneBtn">none</button>
        </span>
      </legend>
      <div class="row key-range" id="keysRangeRow"></div>
    </fieldset>

    <fieldset class="panel" id="exPanel">
      <legend>
        Exclude
        <span class="panel-tools">
          <button class="tool-btn" type="button" id="exAllBtn">all</button>
          <button class="tool-btn" type="button" id="exNoneBtn">none</button>
        </span>
      </legend>
      <div class="row" id="exRow"></div>
    </fieldset>

    <fieldset class="panel" id="mmPanel">
      <legend>Major / Minor</legend>
      <div class="row" id="mmRow"></div>
    </fieldset>

    <fieldset class="panel" id="meterPanel">
      <legend>
        Meter
        <span class="panel-tools">
          <button class="tool-btn" type="button" id="meterAllBtn">all</button>
          <button class="tool-btn" type="button" id="meterNoneBtn">none</button>
        </span>
      </legend>
      <div class="row" id="meterRow"></div>
    </fieldset>

    <fieldset class="panel" id="colPanel">
      <legend>
        Collection
        <span class="panel-tools">
          <button class="tool-btn" type="button" id="colAllBtn">all</button>
          <button class="tool-btn" type="button" id="colNoneBtn">none</button>
        </span>
      </legend>
      <div class="row" id="colRow"></div>
    </fieldset>
  </div>

  <footer><p>created for the University of Iowa Organ Studio</p></footer>

  <script>
    // ------------------------------
    // Config & state
    // ------------------------------
    let tuneFiles = [];

    // DEFAULT: 0#/0♭
    const accidentalsSelected = new Set([0]);
    const keyRangeButtons = new Map();

    const labelFor = k => k.replace(/#/g,"♯").replace(/b/g,"♭");

    const majorMinorVals = ["Major", "Minor"];
    const excludeTonics  = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","Bb","B","Cb"];

    let vrvToolkit = null;
    let currentFile = null;
    let currentTargetKey = "";  // tonic spelling
    let currentMode = "";
    let originalTonic = "";
    let octaveShift = 0;

    let preferFlats = false;

    const originalMeiCache = {};
    const metadataCache = {};
    const MEI_NS = "http://www.music-encoding.org/ns/mei";
    const METADATA_CACHE_VERSION = 11;

    // --- ENGRAVING OPTIONS ---
    const baseOptions = {
      scale: 44,
      pageWidth: 2200,
      pageHeight: 2000,
      adjustPageHeight: true,
      pageMarginLeft: 20,
      pageMarginRight: 20,
      pageMarginTop: 24,
      pageMarginBottom: 24,
      spacingSystem: 10,
      spacingStaff: 8,
      spacingLinear: 0.16,
      spacingNonLinear: 0.40,
      minMeasureWidth: 44,
      justifyVertically: false,
      breaks: "auto",
      spacingLyrics: 6
    };

    const SCALE_MIN = 30;
    const SCALE_MAX = 200;
    const SCALE_STEP = 2;

    const SPACING_MIN = 0.08;
    const SPACING_MAX = 0.80;
    const SPACING_STEP = 0.01;

    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
    function debounce(fn, delay = 120) {
      let t = null;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
    }

    // ------------------------------
    // Forbidden key spellings (as requested)
    // ------------------------------
    const FORBIDDEN_MAJOR = new Set(["D#","E#","B#"]);
    const FORBIDDEN_MINOR = new Set(["Cb","E#","B#"]);

    function normalizeTonic(tonic) {
      if (!tonic || typeof tonic !== "string") return "";
      const m = tonic.match(/^([A-Ga-g])([#bB])?$/);
      if (!m) return tonic;
      let letter = m[1].toUpperCase();
      let acc = (m[2] || "");
      if (acc === "B") acc = "b";
      return letter + acc;
    }

    function isForbiddenTonicForMode(tonic, mode) {
      const T = normalizeTonic(tonic);
      if (!T) return false;
      if (mode === "minor") return FORBIDDEN_MINOR.has(T);
      return FORBIDDEN_MAJOR.has(T);
    }

    function sanitizeTonicForMode(tonic, mode) {
      let T = normalizeTonic(tonic);
      if (!T) return "";

      // Cb minor forbidden -> B minor
      if (mode === "minor" && T === "Cb") return "B";

      // D# major forbidden -> Eb major
      if (mode === "major" && T === "D#") return "Eb";

      // E# any forbidden -> F
      if (T === "E#") return "F";

      // B# any forbidden -> C
      if (T === "B#") return "C";

      return T;
    }

    // ------------------------------
    // Enharmonic pairs
    // ------------------------------
    const ENHARMONIC_PAIRS = [
      ["C#", "Db"],
      ["D#", "Eb"],
      ["F#", "Gb"],
      ["G#", "Ab"],
      ["B",  "Cb"]
    ];
    const ENHARMONIC_MAP = Object.fromEntries(
      ENHARMONIC_PAIRS.flatMap(([a,b]) => [[a,b],[b,a]])
    );

    function toPreferredSpelling(tonic, mode) {
      const t = normalizeTonic(tonic);
      if (!ENHARMONIC_MAP[t]) return sanitizeTonicForMode(t, mode);

      const pair = ENHARMONIC_PAIRS.find(([a,b]) => a === t || b === t);
      if (!pair) return sanitizeTonicForMode(t, mode);

      const [sharpSide, flatSide] = pair;
      const candidate = preferFlats ? flatSide : sharpSide;

      // If the candidate is forbidden, use the other spelling if legal, else sanitize
      if (isForbiddenTonicForMode(candidate, mode)) {
        const other = (candidate === sharpSide) ? flatSide : sharpSide;
        if (!isForbiddenTonicForMode(other, mode)) return other;
        return sanitizeTonicForMode(candidate, mode);
      }

      return candidate;
    }

    // ------------------------------
    // Pitch classes for half-step buttons
    // Never emit A#, B#, E#
    // ------------------------------
    const PITCH_INDEX = {
      "C":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"F":5,
      "F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11,"Cb":11,
      "B#":0,"E#":5,"Fb":4,"Cb":11
    };

    function tonicToPc(tonic) {
      const t = normalizeTonic(String(tonic || ""));
      return (t in PITCH_INDEX) ? PITCH_INDEX[t] : null;
    }

    function pickSpellingForPc(pc, mode) {
      const idx = ((pc % 12) + 12) % 12;

      // Hard-map the three problem pcs:
      // 0 => C (never B#)
      if (idx === 0) return "C";
      // 5 => F (never E#)
      if (idx === 5) return "F";
      // 10 => Bb (never A#)
      if (idx === 10) return "Bb";

      const sharp = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][idx];
      const flat  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","Cb"][idx];

      const candidate = preferFlats ? flat : sharp;
      return sanitizeTonicForMode(candidate, mode);
    }

    function shiftTonicBySemitone(tonic, delta, mode) {
      const pc = tonicToPc(tonic);
      if (pc == null) return tonic;
      const next = (pc + delta + 1200) % 12;
      return pickSpellingForPc(next, mode);
    }

    // ------------------------------
    // Key signature lookup (includes D# minor, G# minor)
    // ------------------------------
    const KEY_SIG_BY_TONIC = {
      "C":  { major:{t:"none",n:0}, minor:{t:"f",n:3} },
      "G":  { major:{t:"s",n:1},   minor:{t:"f",n:2} },
      "D":  { major:{t:"s",n:2},   minor:{t:"f",n:1} },
      "A":  { major:{t:"s",n:3},   minor:{t:"none",n:0} },
      "E":  { major:{t:"s",n:4},   minor:{t:"s",n:1} },
      "B":  { major:{t:"s",n:5},   minor:{t:"s",n:2} },
      "F#": { major:{t:"s",n:6},   minor:{t:"s",n:3} },
      "C#": { major:{t:"s",n:7},   minor:{t:"s",n:4} },

      // minor-only spellings needed for stable toggling (but we still ban D# MAJOR)
      "G#": { major:null,          minor:{t:"s",n:5} }, // = Ab minor enharmonic
      "D#": { major:null,          minor:{t:"s",n:6} }, // = Eb minor enharmonic

      "F":  { major:{t:"f",n:1},   minor:{t:"f",n:4} },
      "Bb": { major:{t:"f",n:2},   minor:{t:"f",n:5} },
      "Eb": { major:{t:"f",n:3},   minor:{t:"f",n:6} },
      "Ab": { major:{t:"f",n:4},   minor:{t:"f",n:7} },
      "Db": { major:{t:"f",n:5},   minor:{t:"s",n:4} },
      "Gb": { major:{t:"f",n:6},   minor:{t:"s",n:3} },
      "Cb": { major:{t:"f",n:7},   minor:{t:"f",n:7} }
    };

    function keySigFor(tonic, mode) {
      const T = normalizeTonic(tonic);
      const entry = KEY_SIG_BY_TONIC[T];
      if (!entry) return { sig: "", label: `${labelFor(T)} ${mode}` };
      const pick = (mode === "minor") ? entry.minor : entry.major;
      if (!pick || pick.t === "none" || pick.n === 0) return { sig: "", label: `${labelFor(T)} ${mode}` };
      const sig = `${pick.n}${pick.t === "s" ? "s" : "f"}`;
      return { sig, label: `${labelFor(T)} ${mode}` };
    }

    function tonicsByAccidentalsSelected(mode, selectedSet) {
      const keyMode = (mode === "minor") ? "minor" : "major";
      return Object.keys(KEY_SIG_BY_TONIC).filter(T => {
        const pick = KEY_SIG_BY_TONIC[T][keyMode];
        if (!pick) return false;
        if (!selectedSet.has(pick.n)) return false;
        if (isForbiddenTonicForMode(T, keyMode)) return false;
        return true;
      });
    }

    // ------------------------------
    // Compute transpose interval directly (fixes ALL the mismatches)
    // ------------------------------
    function intervalLabelForSemisCompound(semitonesAbs) {
      const simple = ["P1","m2","M2","m3","M3","P4","d5","P5","m6","M6","m7","M7"];
      if (semitonesAbs <= 11) return simple[semitonesAbs];
      const s = semitonesAbs - 12;
      const compound = ["P8","m9","M9","m10","M10","P11","d12","P12","m13","M13","m14","M14"];
      if (s <= 11) return compound[s];
      if (semitonesAbs === 24) return "P15";
      return "P1";
    }

    function computeTransposeIntervalString(origTonic, targetTonic, octaveShift) {
      const o = tonicToPc(origTonic);
      const t = tonicToPc(targetTonic);
      if (o == null || t == null) return "";
      const up = (t - o + 12) % 12;
      const down = (o - t + 12) % 12;
      let signed = (up <= down) ? +up : -down;
      signed += (octaveShift || 0) * 12;
      const sign = signed < 0 ? "-" : "+";
      const label = intervalLabelForSemisCompound(Math.abs(signed));
      return sign + label;
    }

    // ------------------------------
    // Force key signature in MEI (so engraving matches label)
    // ------------------------------
    function applyForcedKeySig(meiText, tonic, mode) {
      const T = sanitizeTonicForMode(tonic, mode);
      const { sig } = keySigFor(T, mode);

      const xml = new DOMParser().parseFromString(meiText, "application/xml");

      const scoreDefs = Array.from(xml.getElementsByTagNameNS(MEI_NS, "scoreDef"));
      const staffDefs = Array.from(xml.getElementsByTagNameNS(MEI_NS, "staffDef"));
      const targets = scoreDefs.concat(staffDefs);

      targets.forEach(el => {
        // clear both common key sig attrs
        if (el.hasAttribute("key.sig")) el.removeAttribute("key.sig");
        if (el.hasAttribute("keysig"))  el.removeAttribute("keysig");

        // write both for robustness
        if (sig) {
          el.setAttribute("key.sig", sig);
          el.setAttribute("keysig",  sig);
        } else {
          el.setAttribute("keysig", "0");
        }

        el.setAttribute("key.mode", mode || "major");
      });

      return new XMLSerializer().serializeToString(xml);
    }

    // ------------------------------
    // UI builders
    // ------------------------------
    function clearRow(containerId) {
      const row = document.getElementById(containerId);
      while (row.firstChild) row.removeChild(row.firstChild);
    }

    function setAllCheckboxes(containerId, checked) {
      document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(el => {
        if (!el.disabled) el.checked = !!checked;
      });
    }

    function addPlainCheckboxes(containerId, values, defaultChecked = true, labelTransform = null) {
      const row = document.getElementById(containerId);
      values.forEach(val => {
        const id = `${containerId}_${String(val).replace(/[^A-Za-z0-9]/g,'_')}`;
        const label = document.createElement('label');
        label.className = 'chk-label';
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.id = id; cb.value = val; cb.checked = defaultChecked;
        const span = document.createElement('span');
        span.textContent = labelTransform ? labelTransform(val) : val;
        label.appendChild(cb); label.appendChild(span);
        row.appendChild(label);
      });
    }

    function addExcludeCheckboxes(containerId, values) {
      const row = document.getElementById(containerId);
      values.forEach(val => {
        const id = `${containerId}_${String(val).replace(/[^A-Za-z0-9]/g,'_')}`;
        const label = document.createElement('label');
        label.className = 'chk-label';
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.id = id; cb.value = val; cb.checked = false;
        const span = document.createElement('span');
        span.textContent = labelFor(val);
        label.appendChild(cb); label.appendChild(span);
        row.appendChild(label);
      });
    }

    function getChecked(containerId) {
      const out = [];
      document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(el => {
        if (el.checked) out.push(el.value);
      });
      return out;
    }

    function addAccidentalRangeButtons(containerId) {
      const row = document.getElementById(containerId);
      for (let n = 0; n <= 7; n++) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'range-btn' + (accidentalsSelected.has(n) ? ' active' : '');
        btn.textContent = `${n}#/${n}♭`;
        btn.title = `Include keys with exactly ${n} accidentals (sharp or flat)`;
        btn.addEventListener('click', () => {
          if (accidentalsSelected.has(n)) { accidentalsSelected.delete(n); btn.classList.remove('active'); }
          else { accidentalsSelected.add(n); btn.classList.add('active'); }
        });
        row.appendChild(btn);
        keyRangeButtons.set(n, btn);
      }
    }

    function keyRangeSelectAll() {
      for (let n = 0; n <= 7; n++) accidentalsSelected.add(n);
      for (let n = 0; n <= 7; n++) keyRangeButtons.get(n)?.classList.add('active');
    }
    function keyRangeSelectNone() {
      accidentalsSelected.clear();
      for (let n = 0; n <= 7; n++) keyRangeButtons.get(n)?.classList.remove('active');
    }

    // ------------------------------
    // Metadata parsing (same as before, includes multi-collection)
    // ------------------------------
    function nodelistToArray(nl) { return Array.prototype.slice.call(nl || []); }
    function allByTagNS(xml, tag) { return nodelistToArray(xml.getElementsByTagNameNS(MEI_NS, tag)); }
    function firstByTagNS(xml, tag) {
      const nl = xml.getElementsByTagNameNS(MEI_NS, tag);
      return nl && nl.length ? nl[0] : null;
    }

    function parseCommentMetadataFromXml(xmlDoc) {
      const meiRoot = firstByTagNS(xmlDoc, "mei") || xmlDoc.documentElement;
      const walker = xmlDoc.createTreeWalker(meiRoot, NodeFilter.SHOW_COMMENT, null);
      const lines = [];
      for (let n = walker.nextNode(); n; n = walker.nextNode()) {
        const text = (n.nodeValue || "").trim();
        if (!text) continue;
        text.split(/\r?\n/).forEach(line => {
          const s = line.trim();
          if (s) lines.push(s);
        });
      }
      if (!lines.length) return null;

      const md = { keyMode: "", keyTonic: "", meterSig: "", collections: [], title: "" };
      for (const line of lines) {
        let mm = line.match(/^key\s*:\s*([A-Ga-g])([#bB])?\s+(major|minor)\s*$/i);
        if (mm) { md.keyTonic = mm[1].toUpperCase() + ((mm[2] || "").replace("B","b")); md.keyMode = mm[3].toLowerCase(); continue; }

        mm = line.match(/^keyTonic\s*:\s*([A-Ga-g])([#bB])?\s*$/i);
        if (mm) { md.keyTonic = mm[1].toUpperCase() + ((mm[2] || "").replace("B","b")); continue; }

        mm = line.match(/^keyMode\s*:\s*(major|minor)\s*$/i);
        if (mm) { md.keyMode = mm[1].toLowerCase(); continue; }

        mm = line.match(/^meterSig\s*:\s*(\d+)\s*\/\s*(\d+)\s*$/i);
        if (mm) { md.meterSig = `${mm[1]}/${mm[2]}`; continue; }

        mm = line.match(/^collection\s*:\s*(.+)$/i);
        if (mm) { const c = mm[1].trim(); if (c) md.collections.push(c); continue; }

        mm = line.match(/^title\s*:\s*(.+)$/i);
        if (mm) { md.title = mm[1].trim(); continue; }
      }
      return md;
    }

    function meterSigFromXml(xml) {
      const mSig = firstByTagNS(xml, "meterSig");
      const count = (mSig?.getAttribute("count") || "").trim();
      const unit  = (mSig?.getAttribute("unit")  || "").trim();
      return (count && unit) ? `${count}/${unit}` : "";
    }

    function collectionsFromXml(xml) {
      const identifiers = allByTagNS(xml, "identifier");
      return identifiers
        .filter(el => (el.getAttribute("type") || "").toLowerCase() === "collection")
        .map(el => (el.textContent || "").trim())
        .filter(Boolean);
    }

    async function fetchMei(fileName) {
      if (!originalMeiCache[fileName]) {
        const res = await fetch(fileName, { cache: 'no-cache' });
        if (!res.ok) throw new Error(`Failed to fetch ${fileName}: ${res.status}`);
        originalMeiCache[fileName] = await res.text();
      }
      return originalMeiCache[fileName];
    }

    async function getMetadata(fileName) {
      const cached = metadataCache[fileName];
      if (cached && cached.__v === METADATA_CACHE_VERSION) return cached;

      const meiText = await fetchMei(fileName);
      const xml = new DOMParser().parseFromString(meiText, "application/xml");

      const fromComments = parseCommentMetadataFromXml(xml) || {};
      const keys = allByTagNS(xml, "key");
      const keyEl = keys.length ? keys[0] : null;

      const keyMode  = (fromComments.keyMode || (keyEl?.getAttribute("mode") || "")).trim();
      const pname    = (keyEl?.getAttribute("pname") || "").trim().toLowerCase();
      const accid    = (keyEl?.getAttribute("accid") || "").trim().toLowerCase();
      const keyTonic = (fromComments.keyTonic || (pname ? (pname.toUpperCase() + (accid === "s" ? "#" : accid === "f" ? "b" : "")) : "")).trim();

      const collections = (fromComments.collections && fromComments.collections.length)
        ? fromComments.collections
        : collectionsFromXml(xml);

      const meterSig = (fromComments.meterSig || meterSigFromXml(xml)).trim();

      const titleEl = firstByTagNS(xml, "title");
      const title = (fromComments.title || (titleEl?.textContent || "")).trim();

      const out = { keyMode, keyTonic, collections, meterSig, title, __v: METADATA_CACHE_VERSION };
      metadataCache[fileName] = out;
      return out;
    }

    async function buildCollectionsUIFromAllTunes() {
      clearRow("colRow");
      const set = new Set();
      for (const f of tuneFiles) {
        try { (await getMetadata(f)).collections.forEach(c => set.add(c)); } catch (e) {}
      }
      const list = Array.from(set).sort((a,b) => a.localeCompare(b));
      if (!list.length) {
        addPlainCheckboxes("colRow", ["(no collections found)"], true);
        const el = document.querySelector(`#colRow input[type="checkbox"]`);
        if (el) el.disabled = true;
        return;
      }
      addPlainCheckboxes("colRow", list, true);
    }

    async function buildMetersUIFromAllTunes() {
      clearRow("meterRow");
      const set = new Set();
      for (const f of tuneFiles) {
        try {
          const md = await getMetadata(f);
          if (md.meterSig) set.add(md.meterSig);
        } catch (e) {}
      }
      const list = Array.from(set).sort((a,b) => a.localeCompare(b));
      if (!list.length) {
        addPlainCheckboxes("meterRow", ["(no meters found)"], true);
        const el = document.querySelector(`#meterRow input[type="checkbox"]`);
        if (el) el.disabled = true;
        return;
      }
      addPlainCheckboxes("meterRow", list, true);
    }

    // ------------------------------
    // Strip title for rendering
    // ------------------------------
    function stripMeiTitle(meiText) {
      try {
        const xml = new DOMParser().parseFromString(meiText, "application/xml");
        const titleStmts = allByTagNS(xml, "titleStmt");
        for (const ts of titleStmts) {
          if (ts && ts.parentNode) ts.parentNode.removeChild(ts);
        }
        return new XMLSerializer().serializeToString(xml);
      } catch (e) { return meiText; }
    }

    // ------------------------------
    // Status badges
    // ------------------------------
    function updateScaleBadge() {
      const badge = document.getElementById('scaleBadge');
      if (badge) badge.textContent = `Scale: ${baseOptions.scale}`;
    }
    function updateSpacingBadge() {
      const badge = document.getElementById('spacingBadge');
      if (badge) {
        const lin = baseOptions.spacingLinear.toFixed(2);
        const non = baseOptions.spacingNonLinear.toFixed(2);
        badge.textContent = `Spacing: ${lin} / ${non}`;
      }
    }

    function setStatus(fileName, keyShown, titleText = "") {
      const tuneName = (fileName && fileName !== "—") ? fileName.split('/').pop().replace(/\.mei$/i,'') : "—";
      document.getElementById('statusTune').textContent = `File: ${tuneName}`;
      document.getElementById('statusKey').textContent  = `Key: ${keyShown || "—"}`;
      const titleBar = document.getElementById('titleBar');
      if (titleBar) titleBar.textContent = `Title: ${titleText || "—"}`;
    }

    // ------------------------------
    // Rendering
    // ------------------------------
    function computeResponsivePageWidth() {
      const viewer = document.getElementById('viewer');
      const w = viewer.clientWidth;
      return Math.max(1400, Math.floor(w * 2.25));
    }

    async function renderCurrent() {
      if (!currentFile || !vrvToolkit) return;

      let meiData = await fetchMei(currentFile);
      meiData = stripMeiTitle(meiData);

      // Force the target keysig into MEI (this makes engraving match the label).
      if (currentTargetKey && currentMode) {
        meiData = applyForcedKeySig(meiData, currentTargetKey, currentMode);
      }

      const transposeStr = (currentTargetKey && originalTonic)
        ? computeTransposeIntervalString(originalTonic, currentTargetKey, octaveShift)
        : (octaveShift ? ((octaveShift > 0 ? "+" : "-") + "P8") : "");

      const options = {
        ...baseOptions,
        pageWidth: computeResponsivePageWidth(),
        transpose: transposeStr
      };

      vrvToolkit.setOptions(options);
      vrvToolkit.loadData(meiData);

      const svg = vrvToolkit.renderToSVG(1, {});
      document.getElementById('svg').innerHTML = svg;

      updateScaleBadge();
      updateSpacingBadge();

      const shown = currentTargetKey
        ? `${labelFor(currentTargetKey)} ${currentMode}`
        : (octaveShift ? (octaveShift > 0 ? "8va↑" : "8va↓") : "original");

      try {
        const md = await getMetadata(currentFile);
        setStatus(currentFile, shown, (md.title || "").trim());
      } catch (e) {
        setStatus(currentFile, shown, "");
      }
    }

    // ------------------------------
    // Filtering & selection
    // ------------------------------
    async function pickRandomFilteredTune() {
      const mmSelected = getChecked('mmRow');
      const meterSelected = getChecked('meterRow');
      const colSelected = getChecked('colRow');

      const candidates = [];
      for (const f of tuneFiles) {
        try {
          const md = await getMetadata(f);

          const mmTag = (md.keyMode?.toLowerCase() === "minor") ? "Minor" : "Major";
          const mmOk  = mmSelected.length === 0 ? true : mmSelected.includes(mmTag);

          const meterOk = meterSelected.length === 0 ? true : (md.meterSig ? meterSelected.includes(md.meterSig) : false);

          const cols = (md.collections && md.collections.length) ? md.collections : [];
          const colOk = colSelected.length === 0 ? true : cols.some(c => colSelected.includes(c));

          if (mmOk && meterOk && colOk) candidates.push(f);
        } catch (e) {}
      }
      if (!candidates.length) throw new Error("No tunes match the selected tag filters.");
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

    function readInitialKeySigFromXml(xml) {
      const scoreDefs = allByTagNS(xml, "scoreDef");
      const staffDefs = allByTagNS(xml, "staffDef");
      const first = scoreDefs[0] || staffDefs[0] || null;
      let sig = "";
      if (first) sig = first.getAttribute("keysig") || first.getAttribute("key.sig") || "";
      sig = (sig || "").trim();
      if (!sig || sig === "0") return { t: "none", n: 0 };
      const m = sig.match(/^(\d+)([sf])$/);
      if (!m) return { t: "none", n: 0 };
      return { t: m[2], n: Number(m[1]) };
    }

    function inferTonicFromKeySig(mode, t, n) {
      const keyMode = (mode === "minor") ? "minor" : "major";
      const found = Object.keys(KEY_SIG_BY_TONIC).find(T => {
        const pick = KEY_SIG_BY_TONIC[T][keyMode];
        return pick && pick.t === t && pick.n === n;
      });
      if (!found && n === 0) return keyMode === "major" ? "C" : "A";
      return found || "";
    }

    async function showRandomTune() {
      currentFile = await pickRandomFilteredTune();
      const md = await getMetadata(currentFile);
      currentMode = (md.keyMode?.toLowerCase() === "minor") ? "minor" : "major";
      originalTonic = md.keyTonic || "";

      if (!originalTonic) {
        const rawMei = await fetchMei(currentFile);
        const xml = new DOMParser().parseFromString(rawMei, "application/xml");
        const { t, n } = readInitialKeySigFromXml(xml);
        originalTonic = inferTonicFromKeySig(currentMode, t, n);
      }

      let allowed = tonicsByAccidentalsSelected(currentMode, accidentalsSelected);
      const excluded = new Set(getChecked('exRow'));
      allowed = allowed.filter(T => !excluded.has(T));

      currentTargetKey = allowed.length ? allowed[Math.floor(Math.random() * allowed.length)] : "";
      currentTargetKey = sanitizeTonicForMode(currentTargetKey, currentMode);
      currentTargetKey = toPreferredSpelling(currentTargetKey, currentMode);

      octaveShift = 0;
      await renderCurrent();
    }

    // ------------------------------
    // Buttons
    // ------------------------------
    async function octaveUp()   { octaveShift += 1; await renderCurrent(); }
    async function octaveDown() { octaveShift -= 1; await renderCurrent(); }

    async function halfStepUp() {
      if (!currentTargetKey) currentTargetKey = originalTonic || "C";
      currentTargetKey = shiftTonicBySemitone(currentTargetKey, +1, currentMode);
      currentTargetKey = toPreferredSpelling(currentTargetKey, currentMode);
      await renderCurrent();
    }

    async function halfStepDown() {
      if (!currentTargetKey) currentTargetKey = originalTonic || "C";
      currentTargetKey = shiftTonicBySemitone(currentTargetKey, -1, currentMode);
      currentTargetKey = toPreferredSpelling(currentTargetKey, currentMode);
      await renderCurrent();
    }

    async function toggleEnharmonic() {
      preferFlats = !preferFlats;
      if (currentTargetKey) {
        // Flip spelling if it has a defined pair, otherwise just re-apply preference.
        const t = normalizeTonic(currentTargetKey);
        const swapped = ENHARMONIC_MAP[t] ? ENHARMONIC_MAP[t] : t;
        // Apply preference + bans
        currentTargetKey = toPreferredSpelling(swapped, currentMode);
      }
      await renderCurrent();
    }

    // ------------------------------
    // Discover tunes
    // ------------------------------
    async function discoverTunes() {
      try {
        const res = await fetch(`tunes.json?_=${Date.now()}`, { cache: 'no-cache' });
        if (res.ok) {
          const arr = await res.json();
          const mei = (Array.isArray(arr) ? arr : [])
            .filter(x => typeof x === 'string')
            .map(x => x.split('#')[0].split('?')[0])
            .filter(x => /\.mei$/i.test(x))
            .map(x => x.replace(/^\.?\//,'').replace(/\\/g,'/'));
          if (mei.length) { tuneFiles = Array.from(new Set(mei)); return; }
        }
      } catch (e) {}

      try {
        const res = await fetch(`tunes/?_=${Date.now()}`, { cache: 'no-cache' });
        if (res.ok) {
          const html = await res.text();
          const tmp = document.createElement('div'); tmp.innerHTML = html;
          const hrefs = Array.from(tmp.querySelectorAll('a[href]')).map(a => a.getAttribute('href')).filter(Boolean);
          const paths = hrefs
            .map(h => h.split('#')[0].split('?')[0])
            .filter(h => /\.mei$/i.test(h))
            .map(h => (h.startsWith('tunes/') ? h : `tunes/${h.replace(/^\.?\//,'')}`));
          if (paths.length) { tuneFiles = Array.from(new Set(paths)); return; }
        }
      } catch (e) {}

      tuneFiles = [];
    }

    // ------------------------------
    // Load Verovio
    // ------------------------------
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(s);
      });
    }

    async function init() {
      addAccidentalRangeButtons("keysRangeRow");
      addExcludeCheckboxes("exRow", excludeTonics);
      addPlainCheckboxes("mmRow", majorMinorVals, true);

      document.getElementById('keysAllBtn').addEventListener('click', keyRangeSelectAll);
      document.getElementById('keysNoneBtn').addEventListener('click', keyRangeSelectNone);

      document.getElementById('exAllBtn').addEventListener('click', () => setAllCheckboxes('exRow', true));
      document.getElementById('exNoneBtn').addEventListener('click', () => setAllCheckboxes('exRow', false));

      document.getElementById('meterAllBtn').addEventListener('click', () => setAllCheckboxes('meterRow', true));
      document.getElementById('meterNoneBtn').addEventListener('click', () => setAllCheckboxes('meterRow', false));

      document.getElementById('colAllBtn').addEventListener('click', () => setAllCheckboxes('colRow', true));
      document.getElementById('colNoneBtn').addEventListener('click', () => setAllCheckboxes('colRow', false));

      await discoverTunes();
      await buildCollectionsUIFromAllTunes();
      await buildMetersUIFromAllTunes();

      const verovioUrl = 'https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js?v=latest';
      try { await loadScript(verovioUrl); } catch (e) { setStatus("—", "Failed to load Verovio", ""); return; }

      const waitForGlobal = () => new Promise((resolve, reject) => {
        const start = performance.now(); const maxWaitMs = 10000;
        (function poll() {
          if (window.verovio && window.verovio.module) return resolve();
          if (performance.now() - start > maxWaitMs) return reject(new Error('Verovio global not found'));
          setTimeout(poll, 50);
        })();
      });

      try {
        await waitForGlobal();
        window.verovio.module.onRuntimeInitialized = () => {
          vrvToolkit = new verovio.toolkit();

          document.getElementById('randomBtn').disabled = false;
          document.getElementById('octUpBtn').disabled = false;
          document.getElementById('octDownBtn').disabled = false;

          document.getElementById('enharmonicBtn').disabled = false;
          document.getElementById('halfUpBtn').disabled = false;
          document.getElementById('halfDownBtn').disabled = false;

          document.getElementById('spacingPlusBtn').disabled = false;
          document.getElementById('spacingMinusBtn').disabled = false;

          document.getElementById('musicPlusBtn').disabled = false;
          document.getElementById('musicMinusBtn').disabled = false;

          document.getElementById('randomBtn').addEventListener('click', () => showRandomTune().catch(console.error));
          document.getElementById('octUpBtn').addEventListener('click', () => octaveUp().catch(console.error));
          document.getElementById('octDownBtn').addEventListener('click', () => octaveDown().catch(console.error));

          document.getElementById('halfUpBtn').addEventListener('click', () => halfStepUp().catch(console.error));
          document.getElementById('halfDownBtn').addEventListener('click', () => halfStepDown().catch(console.error));
          document.getElementById('enharmonicBtn').addEventListener('click', () => toggleEnharmonic().catch(console.error));

          document.getElementById('spacingPlusBtn').addEventListener('click', () => {
            baseOptions.spacingLinear = clamp(baseOptions.spacingLinear + SPACING_STEP, SPACING_MIN, SPACING_MAX);
            baseOptions.spacingNonLinear = clamp(baseOptions.spacingNonLinear + SPACING_STEP, SPACING_MIN, SPACING_MAX);
            updateSpacingBadge(); renderCurrent();
          });
          document.getElementById('spacingMinusBtn').addEventListener('click', () => {
            baseOptions.spacingLinear = clamp(baseOptions.spacingLinear - SPACING_STEP, SPACING_MIN, SPACING_MAX);
            baseOptions.spacingNonLinear = clamp(baseOptions.spacingNonLinear - SPACING_STEP, SPACING_MIN, SPACING_MAX);
            updateSpacingBadge(); renderCurrent();
          });

          document.getElementById('musicPlusBtn').addEventListener('click', () => {
            baseOptions.scale = clamp(baseOptions.scale + SCALE_STEP, SCALE_MIN, SCALE_MAX);
            updateScaleBadge(); renderCurrent();
          });
          document.getElementById('musicMinusBtn').addEventListener('click', () => {
            baseOptions.scale = clamp(baseOptions.scale - SCALE_STEP, SCALE_MIN, SCALE_MAX);
            updateScaleBadge(); renderCurrent();
          });

          window.addEventListener('resize', debounce(() => renderCurrent(), 150));

          updateScaleBadge();
          updateSpacingBadge();

          if (tuneFiles.length) showRandomTune().catch(console.error);
        };
        setStatus("—", "Initializing Verovio…", "");
      } catch (e) {
        setStatus("—", "Verovio not available", "");
      }
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
